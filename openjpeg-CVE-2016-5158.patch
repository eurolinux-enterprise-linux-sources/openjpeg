From 4342fc54f45ae29b06d70bf55f0d2a6a6ae218d5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Nikola=20Forr=C3=B3?= <nforro@redhat.com>
Date: Tue, 21 Feb 2017 09:55:40 +0100
Subject: [PATCH 2/4] Fix CVE-2016-5158

---
 libopenjpeg/dwt.c | 45 ++++++++++++++++++++++++++++++++++++++-------
 libopenjpeg/dwt.h |  4 ++--
 libopenjpeg/t1.c  | 22 ++++++++++++++++++----
 libopenjpeg/tcd.c | 10 ++++++++--
 4 files changed, 66 insertions(+), 15 deletions(-)

diff --git a/libopenjpeg/dwt.c b/libopenjpeg/dwt.c
index 78d18d1..5ac4750 100755
--- a/libopenjpeg/dwt.c
+++ b/libopenjpeg/dwt.c
@@ -118,7 +118,7 @@ static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno
 /**
 Inverse wavelet transform in 2-D.
 */
-static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int i, DWT1DFN fn);
+static bool dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int i, DWT1DFN fn);
 
 /*@}*/
 
@@ -379,8 +379,8 @@ void dwt_encode(opj_tcd_tilecomp_t * tilec) {
 /* <summary>                            */
 /* Inverse 5-3 wavelet transform in 2-D. */
 /* </summary>                           */
-void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres) {
-	dwt_decode_tile(tilec, numres, &dwt_decode_1);
+bool dwt_decode(opj_tcd_tilecomp_t* tilec, int numres) {
+	return dwt_decode_tile(tilec, numres, &dwt_decode_1);
 }
 
 
@@ -516,7 +516,7 @@ static int dwt_decode_max_resolution(opj_tcd_resolution_t* restrict r, int i) {
 /* <summary>                            */
 /* Inverse wavelet transform in 2-D.     */
 /* </summary>                           */
-static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int numres, DWT1DFN dwt_1D) {
+static bool dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int numres, DWT1DFN dwt_1D) {
 	dwt_t h;
 	dwt_t v;
 
@@ -527,7 +527,18 @@ static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int numres, DWT1DFN dwt_1
 
 	int w = tilec->x1 - tilec->x0;
 
-	h.mem = opj_aligned_malloc(dwt_decode_max_resolution(tr, numres) * sizeof(int));
+	uint32_t h_mem_count = dwt_decode_max_resolution(tr, numres);
+
+	if (((uint32_t)-1) / (uint32_t)sizeof(int) < h_mem_count) {
+		return false;
+	}
+
+	h.mem = (int*)opj_aligned_malloc(h_mem_count * sizeof(int));
+
+	if (h.mem == NULL) {
+		return false;
+	}
+
 	v.mem = h.mem;
 
 	while( --numres) {
@@ -563,6 +574,8 @@ static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int numres, DWT1DFN dwt_1
 		}
 	}
 	opj_aligned_free(h.mem);
+
+	return true;
 }
 
 static void v4dwt_interleave_h(v4dwt_t* restrict w, float* restrict a, int x, int size){
@@ -743,7 +756,7 @@ static void v4dwt_decode(v4dwt_t* restrict dwt){
 /* <summary>                             */
 /* Inverse 9-7 wavelet transform in 2-D. */
 /* </summary>                            */
-void dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, int numres){
+bool dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, int numres){
 	v4dwt_t h;
 	v4dwt_t v;
 
@@ -754,7 +767,23 @@ void dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, int numres){
 
 	int w = tilec->x1 - tilec->x0;
 
-	h.wavelet = (v4*) opj_aligned_malloc((dwt_decode_max_resolution(res, numres)+5) * sizeof(v4));
+	uint32_t mr = dwt_decode_max_resolution(res, numres);
+
+	if (mr >= ((uint32_t)-5)) {
+		return false;
+	}
+	mr += 5;
+
+	if (((uint32_t)-1) / (uint32_t)sizeof(v4) < mr) {
+		return false;
+	}
+
+	h.wavelet = (v4*) opj_aligned_malloc(mr * sizeof(v4));
+
+	if (h.wavelet == NULL) {
+		return false;
+	}
+
 	v.wavelet = h.wavelet;
 
 	while( --numres) {
@@ -821,5 +850,7 @@ void dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, int numres){
 	}
 
 	opj_aligned_free(h.wavelet);
+
+	return true;
 }
 
diff --git a/libopenjpeg/dwt.h b/libopenjpeg/dwt.h
index adf73e5..09bc31d 100755
--- a/libopenjpeg/dwt.h
+++ b/libopenjpeg/dwt.h
@@ -59,7 +59,7 @@ Apply a reversible inverse DWT transform to a component of an image.
 @param tilec Tile component information (current tile)
 @param numres Number of resolution levels to decode
 */
-void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres);
+bool dwt_decode(opj_tcd_tilecomp_t* tilec, int numres);
 /**
 Get the gain of a subband for the reversible 5-3 DWT.
 @param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
@@ -85,7 +85,7 @@ Apply an irreversible inverse DWT transform to a component of an image.
 @param tilec Tile component information (current tile)
 @param numres Number of resolution levels to decode
 */
-void dwt_decode_real(opj_tcd_tilecomp_t* tilec, int numres);
+bool dwt_decode_real(opj_tcd_tilecomp_t* tilec, int numres);
 /**
 Get the gain of a subband for the irreversible 9-7 DWT.
 @param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
diff --git a/libopenjpeg/t1.c b/libopenjpeg/t1.c
index 3ae5ed3..71e5b5d 100755
--- a/libopenjpeg/t1.c
+++ b/libopenjpeg/t1.c
@@ -844,7 +844,13 @@ static bool allocate_buffers(
 	int flagssize;
 
 	if(datasize > t1->datasize){
-		opj_aligned_free(t1->data);
+		if (t1->data != NULL) {
+			opj_aligned_free(t1->data);
+			t1->data = NULL;
+		}
+		if (((uint32_t)-1) / (uint32_t)sizeof(int) < datasize) {
+			return false;
+		}
 		t1->data = (int*) opj_aligned_malloc(datasize * sizeof(int));
 		if(!t1->data){
 			return false;
@@ -861,7 +867,13 @@ static bool allocate_buffers(
 #endif
 
 	if(flagssize > t1->flagssize){
-		opj_aligned_free(t1->flags);
+		if (t1->flags != NULL) {
+			opj_aligned_free(t1->flags);
+			t1->flags = NULL;
+		}
+		if (((uint32_t)-1) / (uint32_t)sizeof(flag_t) < flagssize) {
+			return false;
+		}
 		t1->flags = (flag_t*) opj_aligned_malloc(flagssize * sizeof(flag_t));
 		if(!t1->flags){
 			return false;
@@ -1119,8 +1131,10 @@ void t1_destroy(opj_t1_t *t1) {
 		/* destroy MQC and RAW handles */
 		mqc_destroy(t1->mqc);
 		raw_destroy(t1->raw);
-		opj_aligned_free(t1->data);
-		opj_aligned_free(t1->flags);
+		if (t1->data != NULL)
+			opj_aligned_free(t1->data);
+		if (t1->flags != NULL)
+			opj_aligned_free(t1->flags);
 		opj_free(t1);
 	}
 }
diff --git a/libopenjpeg/tcd.c b/libopenjpeg/tcd.c
index d94ea97..f68a5d4 100755
--- a/libopenjpeg/tcd.c
+++ b/libopenjpeg/tcd.c
@@ -1428,9 +1428,15 @@ bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno, op
 		numres2decode = tcd->image->comps[compno].resno_decoded + 1;
 		if(numres2decode > 0){
 			if (tcd->tcp->tccps[compno].qmfbid == 1) {
-				dwt_decode(tilec, numres2decode);
+				if (! dwt_decode(tilec, numres2decode)) {
+		            opj_event_msg(tcd->cinfo, EVT_ERROR, "Error during DWT decoding\n");
+        		    return false;
+				}
 			} else {
-				dwt_decode_real(tilec, numres2decode);
+				if (! dwt_decode_real(tilec, numres2decode)) {
+		            opj_event_msg(tcd->cinfo, EVT_ERROR, "Error during DWT decoding\n");
+        		    return false;
+				}
 			}
 		}
 	}
-- 
2.7.4


From 8bc762b6560b18f7d5ad31d5afd30c9771ee8498 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Nikola=20Forr=C3=B3?= <nforro@redhat.com>
Date: Tue, 21 Feb 2017 09:51:12 +0100
Subject: [PATCH 1/4] Fix CVE-2016-5139

---
 libopenjpeg/j2k.c          | 30 ++++++++++++++++----
 libopenjpeg/opj_includes.h | 13 +++++++++
 libopenjpeg/t1.c           |  1 +
 libopenjpeg/tcd.c          | 70 +++++++++++++++++++++++++++++++++++-----------
 4 files changed, 93 insertions(+), 21 deletions(-)

diff --git a/libopenjpeg/j2k.c b/libopenjpeg/j2k.c
index 1c4f776..114888a 100755
--- a/libopenjpeg/j2k.c
+++ b/libopenjpeg/j2k.c
@@ -1647,12 +1647,22 @@ static void j2k_read_eoc(opj_j2k_t *j2k) {
 		opj_tcd_t *tcd = tcd_create(j2k->cinfo);
 		tcd_malloc_decode(tcd, j2k->image, j2k->cp);
 		for (i = 0; i < j2k->cp->tileno_size; i++) {
-			tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
 			tileno = j2k->cp->tileno[i];
-			success = tcd_decode_tile(tcd, j2k->tile_data[tileno], j2k->tile_len[tileno], tileno, j2k->cstr_info);
-			opj_free(j2k->tile_data[tileno]);
-			j2k->tile_data[tileno] = NULL;
-			tcd_free_decode_tile(tcd, i);
+			tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
+			if (j2k->cp->tileno[i] != -1)
+			{
+				tileno = j2k->cp->tileno[i];
+				success = tcd_decode_tile(tcd, j2k->tile_data[tileno], j2k->tile_len[tileno], tileno, j2k->cstr_info);
+				opj_free(j2k->tile_data[tileno]);
+				j2k->tile_data[tileno] = NULL;
+				tcd_free_decode_tile(tcd, i);
+			}
+			else
+			{
+				success = false;
+				opj_free(j2k->tile_data[tileno]);
+				j2k->tile_data[tileno] = NULL;
+			}
 			if (success == false) {
 				j2k->state |= J2K_STATE_ERR;
 				break;
@@ -1823,6 +1833,16 @@ void j2k_destroy_decompress(opj_j2k_t *j2k) {
 		opj_free(j2k->tile_len);
 	}
 	if(j2k->tile_data != NULL) {
+		if(j2k->cp != NULL) {
+			for (i = 0; i < j2k->cp->tileno_size; i++) {
+				int tileno = j2k->cp->tileno[i];
+				if (tileno != -1) {
+					opj_free(j2k->tile_data[tileno]);
+					j2k->tile_data[tileno] = NULL;
+				}
+			}
+		}
+
 		opj_free(j2k->tile_data);
 	}
 	if(j2k->default_tcp != NULL) {
diff --git a/libopenjpeg/opj_includes.h b/libopenjpeg/opj_includes.h
index 80d43df..6e80532 100755
--- a/libopenjpeg/opj_includes.h
+++ b/libopenjpeg/opj_includes.h
@@ -129,4 +129,17 @@ static INLINE long lrintf(float f){
 #endif /* USE_JPWL */
 /* <<JPWL */
 
+#if defined(_WIN32)
+typedef   signed __int8   int8_t;
+typedef unsigned __int8   uint8_t;
+typedef   signed __int16  int16_t;
+typedef unsigned __int16  uint16_t;
+typedef   signed __int32  int32_t;
+typedef unsigned __int32  uint32_t;
+typedef   signed __int64  int64_t;
+typedef unsigned __int64  uint64_t;
+#else
+#include <stdint.h>
+#endif
+
 #endif /* OPJ_INCLUDES_H */
diff --git a/libopenjpeg/t1.c b/libopenjpeg/t1.c
index b95535a..3ae5ed3 100755
--- a/libopenjpeg/t1.c
+++ b/libopenjpeg/t1.c
@@ -1300,6 +1300,7 @@ void t1_decode_cblks(
 					opj_free(cblk->segs);
 				} /* cblkno */
 				opj_free(precinct->cblks.dec);
+				precinct->cblks.dec = NULL;
 			} /* precno */
 		} /* bandno */
 	} /* resno */
diff --git a/libopenjpeg/tcd.c b/libopenjpeg/tcd.c
index e28ba6f..d94ea97 100755
--- a/libopenjpeg/tcd.c
+++ b/libopenjpeg/tcd.c
@@ -688,6 +688,12 @@ void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp,
 
 		tilec->numresolutions = tccp->numresolutions;
 		tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
+
+		if (tilec->resolutions == NULL) {
+			opj_event_msg(tcd->cinfo, EVT_ERROR, "Not enough memory to handle tile component resolutions\n");
+			cp->tileno[tileno] = -1;
+			return;
+		}
 		
 		for (resno = 0; resno < tilec->numresolutions; resno++) {
 			int pdx, pdy;
@@ -721,8 +727,20 @@ void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp,
 			brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
 			brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
 			
-			res->pw = (res->x0 == res->x1) ? 0 : ((brprcxend - tlprcxstart) >> pdx);
-			res->ph = (res->y0 == res->y1) ? 0 : ((brprcyend - tlprcystart) >> pdy);
+			res->pw = (res->x0 == res->x1) ? 0U : ((brprcxend - tlprcxstart) >> pdx);
+			res->ph = (res->y0 == res->y1) ? 0U : ((brprcyend - tlprcystart) >> pdy);
+
+			if ((res->pw != 0U) && ((((uint32_t)-1) / res->pw) < res->ph)) {
+				opj_event_msg(tcd->cinfo, EVT_ERROR, "Not enough memory for tile data\n");
+				cp->tileno[tileno] = -1;
+				return;
+			}
+
+			if ((((uint32_t)-1) / (uint32_t)sizeof(opj_tcd_precinct_t)) < res->pw * res->ph) {
+				opj_event_msg(tcd->cinfo, EVT_ERROR, "Not enough memory for tile data\n");
+				cp->tileno[tileno] = -1;
+				return;
+			}
 			
 			if (resno == 0) {
 				tlcbgxstart = tlprcxstart;
@@ -774,6 +792,12 @@ void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp,
 				band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
 				
 				band->precincts = (opj_tcd_precinct_t *) opj_malloc(res->pw * res->ph * sizeof(opj_tcd_precinct_t));
+
+				if (band->precincts == NULL) {
+					opj_event_msg(tcd->cinfo, EVT_ERROR, "Not enough memory to handle band precints\n");
+					cp->tileno[tileno] = -1;
+					return;
+				}
 				
 				for (precno = 0; precno < res->pw * res->ph; precno++) {
 					int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
@@ -1498,28 +1522,42 @@ void tcd_free_decode(opj_tcd_t *tcd) {
 }
 
 void tcd_free_decode_tile(opj_tcd_t *tcd, int tileno) {
-	int compno,resno,bandno,precno;
+	int compno,resno,bandno,precno,cblkno;
 
 	opj_tcd_image_t *tcd_image = tcd->tcd_image;
 
 	opj_tcd_tile_t *tile = &tcd_image->tiles[tileno];
-	for (compno = 0; compno < tile->numcomps; compno++) {
-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-		for (resno = 0; resno < tilec->numresolutions; resno++) {
-			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-			for (bandno = 0; bandno < res->numbands; bandno++) {
-				opj_tcd_band_t *band = &res->bands[bandno];
-				for (precno = 0; precno < res->ph * res->pw; precno++) {
-					opj_tcd_precinct_t *prec = &band->precincts[precno];
-					if (prec->imsbtree != NULL) tgt_destroy(prec->imsbtree);
-					if (prec->incltree != NULL) tgt_destroy(prec->incltree);
+	if (tile->comps != NULL) {
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+			if (tilec->resolutions != NULL) {
+				for (resno = 0; resno < tilec->numresolutions; resno++) {
+					opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+					for (bandno = 0; bandno < res->numbands; bandno++) {
+						opj_tcd_band_t *band = &res->bands[bandno];
+						if (band->precincts != NULL) {
+							for (precno = 0; precno < res->ph * res->pw; precno++) {
+								opj_tcd_precinct_t *prec = &band->precincts[precno];
+								if (prec->cblks.dec != NULL) {
+									for (cblkno = 0; cblkno < prec->cw * prec->ch; ++cblkno) {
+										opj_tcd_cblk_dec_t* cblk = &prec->cblks.dec[cblkno];
+										opj_free(cblk->data);
+										opj_free(cblk->segs);
+									}
+									opj_free(prec->cblks.dec);
+								}
+								if (prec->imsbtree != NULL) tgt_destroy(prec->imsbtree);
+								if (prec->incltree != NULL) tgt_destroy(prec->incltree);
+							}
+							opj_free(band->precincts);
+						}
+					}
 				}
-				opj_free(band->precincts);
+				opj_free(tilec->resolutions);
 			}
 		}
-		opj_free(tilec->resolutions);
+		opj_free(tile->comps);
 	}
-	opj_free(tile->comps);
 }
 
 
-- 
2.7.4

